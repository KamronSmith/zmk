#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/mouse.h>   // This is required when using &mkp mouse key events.
#include <dt-bindings/zmk/bt.h>      // This is required when using &bt bluetooth commands.
#include <dt-bindings/zmk/outputs.h> // This is required when using the &out output commands.

// This is the key map of the Yackboard v1 with the improved OPY layout.

// The dedicated shift key has got the following behaviour:
// - if held down, it is the shift modifier
// - if held down, but no other key is tapped, it reverts to the default layer (note that this requires the custom retro-tap patch of https://github.com/nickconway/zmk/tree/retro-tap-binding)
// - if tapped once, it is a one-shot shift, i.e. applies shift to the subsequent key
// - if tapped twice, it is my flavour of caps word, i.e. it capitalizes the subsequent word (including the underscore)
//
// This is implemented as follows:
// - first, there is a hold-tap with hold the LSHFT and tap the following sticky key; it has a custom retro-tap behaviour which resets the layer to default
// - the sticky key produces a one-shot version of a macro that applies the following two modifiers
// - the shift modifier (for the one-shot shift) and the momentarily applied special layer L_ONE_SHF (which does nothing other than modifying the behaviour of the shift key)
// - on the special layer L_ONE_SHF the shift key is my flavour of caps-word - otherwise that layer is transparent

/ {
  macros {
    macro_shf: macro_layer_and_shift { // this macro applies the two modifiers when the shift key is tapped for the first time
      compatible = "zmk,behavior-macro";
      label = "MACRO_LAYER_AND_SHIFT";
      #binding-cells = <0>;
      wait-ms = <0>;
      tap-ms = <1>;
      bindings
      = <&macro_press   &mo L_SHF &kp LSHFT>
      , <&macro_pause_for_release>
      , <&macro_release &mo L_SHF &kp LSHFT>
      ;
    };
  };

  behaviors {
    sticky_shift: sticky_layer_and_shift { // this is the sticky behaviour of the macro when the dedicated shift key is pressed for the first time
      compatible = "zmk,behavior-sticky-key";
      label = "STICKY_LAYER_AND_SHIFT";
      #binding-cells = <1>;
      release-after-ms = <1000>;
      bindings = <&macro_shf>;
      ignore-modifiers;
    };
    hold_shift: hold_tap_shift { // this is the hold-tap for the dedicated shift key
      compatible = "zmk,behavior-hold-tap";
      label = "HOLD_TAP_SHIFT";
      #binding-cells = <2>;
      flavor = "balanced";
      retro-tap;
      retro-tap-behavior = "TO_LAYER"; // this requiree the custom retro-tap patch; note that the alternative behaviour is defined using control strings such as this
      retro-tap-param1 = <L_DEF>;
      tapping-term-ms = <200>;
      bindings = <&kp>, <&sticky_shift>;
    };
    mycaps: behavior_my_caps_word { // my version of Caps Word includes the underscore as a letter.
      compatible = "zmk,behavior-caps-word";
      label = "MY_CAPS";
      #binding-cells = <0>;
      continue-list = <UNDER>;
    };
  };
};

// There are two variants of home row hold-tap modifiers: mod-tap for [Ctrl], [Alt] and [Win] and layer-tap for the keys
// that momentarily activate the number, navigation and function layers.

/ {
  behaviors {
    moht: modifier_hold_tap { // the home row modifiers use the following specialization of &ht.
      compatible = "zmk,behavior-hold-tap";
      label = "MODIFIER_HOLD_TAP";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <400>;
      retro-tap;
      quick-tap-ms = <200>;
      bindings = <&kp>, <&kp>;
    };
    lyht: layer_hold_tap { // the home row layer keys for the number layer use the following specialization of &ht.
      compatible = "zmk,behavior-hold-tap";
      label = "LAYER_HOLD_TAP";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <400>;
      retro-tap;
      quick-tap-ms = <250>;
      bindings = <&mo>, <&kp>;
    };
  };
};

// The dedicated layer cycle keys switch layers or, if held down, revert to the basic layer.

/ {
  behaviors {
    ltt: layer_to_tap { // the layer switch key on the right half is &to if tapped and &to if held down
      compatible = "zmk,behavior-hold-tap";
      label = "LAYER_TO_TAP";
      #binding-cells = <2>;
      tapping-term-ms = <200>;
      bindings = <&to>, <&to>;
    };
  };
};

// There are a few keys that use the hold-tap function in order to issue a different symbol if held longer.

/ {
  behaviors {
    ht: hold_tap_general {
      compatible = "zmk,behavior-hold-tap";
      label = "HOLD_TAP_GENERAL";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      bindings = <&kp>, <&kp>;
    };
  };
};

// On the navigation layer, there are two special keys that issue the Emacs commands for beginning and end of document.

/ {
  macros {
    move_beg: meta_less_than {
      label = "M-<";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_tap &kp ESC &kp LESS_THAN>;
    };
    move_end: meta_greater_than {
      label = "M->";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_tap &kp ESC &kp GREATER_THAN>;
    };
  };
};

// For some keys, the shifted variant is constructed manually.

/ {
  behaviors {
    shbs: shift_backspace { // the backspace key with [Shift] is [Del]
      compatible = "zmk,behavior-mod-morph";
      label = "SHIFT_BACKSPACE";
      #binding-cells = <0>;
      bindings = <&kp BSPC>, <&kp DEL>;
      mods = <(MOD_LSFT|MOD_RSFT)>;
    };
    shsz: shift_sz { // the [ß] with [Shift] is the [§] sign
      compatible = "zmk,behavior-mod-morph";
      label = "SHIFT_SZ";
      #binding-cells = <0>;
      bindings = <&kp RA(S)>, <&kp RA(LS(S))>;
      mods = <(MOD_LSFT|MOD_RSFT)>;
    };
  };
};

// The diacritics on the navigation and punctuation layer are non-dead. This is implemented by sending a sequence of
// first the diacritic and then a spcace.
//
// ???
// Note that the degree ° and the slash / are non-dead by default, but I might want to program a dead version, too.
// Add a new hold-tap layer switch for a new layer L_DEAD that produces the dead versions of the following keys.
// Also add the symbols of the US international layout to that layer.

/ {
  macros {
    nd_grave: non_dead_grave { // non-dead version of the grave accent
      label = "NON_DEAD_GRAVE";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_tap &kp GRAVE &kp SPACE>;
    };
    nd_apos: non_dead_apostrophe { // non-dead version of the apostrophe (which otherwise plays the role of the acute accent)
      label = "NON_DEAD_APOSTROPHE";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_tap &kp APOS &kp SPACE>;
    };
    nd_dqt: non_dead_doublequote { // non-dead version of the double quote
      label = "NON_DEAD_DOUBLEQUOTE";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_tap &kp DQT &kp SPACE>;
    };
    nd_caret: non_dead_caret { // non-dead version of the caret
      label = "NON_DEAD_CARET";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_tap &kp CARET &kp SPACE>;
    };
    nd_tilde: non_dead_tilde { // non-dead version of the tilde
      label = "NON_DEAD_TILDE";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      bindings = <&macro_tap &kp TILDE &kp SPACE>;
    };
  };
};

// On the number layer, there are hold-tap keys that send some of these non-dead diacritics.

/ {
  behaviors {
    ht_apos: hold_tap_apostrophe { // a hold-tap that sends the non-dead apostrophe on hold.
      compatible = "zmk,behavior-hold-tap";
      label = "HOLD_TAP_APOSTROPHE";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      bindings = <&nd_apos>, <&kp>;
    };
    ht_caret: hold_tap_caret { // a hold-tap that sends the non-dead caret on hold.
      compatible = "zmk,behavior-hold-tap";
      label = "HOLD_TAP_CARET";
      #binding-cells = <2>;
      flavor = "balanced";
      tapping-term-ms = <200>;
      bindings = <&nd_caret>, <&kp>;
    };
  };
};

// ??? experimental behaviours

/ {
  behaviors {
    ad_z: adaptive_z {
      compatible = "zmk,behavior-antecedent-morph";
      label = "ADAPTIVE_Z";
      #binding-cells = <0>;
      bindings = <&kp Z>, <&kp O>;
      max-delay-ms = <250>;
      antecedents = <E I U>;
    };
    ad_j: adaptive_j {
      compatible = "zmk,behavior-antecedent-morph";
      label = "ADAPTIVE_J";
      #binding-cells = <0>;
      bindings = <&kp J>, <&kp K>;
      max-delay-ms = <250>;
      antecedents = <E I U>;
    };
    ad_oe: adaptive_oe {
      compatible = "zmk,behavior-antecedent-morph";
      label = "ADAPTIVE_OE";
      #binding-cells = <0>;
      bindings = <&kp RA(P)>, <&kp I>;
      max-delay-ms = <250>;
      antecedents = <E I U>;
    };
    ad_ae: adaptive_ae {
      compatible = "zmk,behavior-antecedent-morph";
      label = "ADAPTIVE_AE";
      #binding-cells = <0>;
      bindings = <&kp RA(Q)>, <&kp P>;
      max-delay-ms = <250>;
      antecedents = <E I U>;
    };
  };
};

/ {
  keymap {
    compatible = "zmk,keymap";

// +-------+-------+-------+-------+-------+-------+       +-------+-------+-------+-------+-------+-------+
// |       |       |       |       |       |       |       |       |       |       |       |       |       |
// +-------+-------+-------+-------+-------+-------+       +-------+-------+-------+-------+-------+-------+
// |       |       |       |       |       |       |       |       |       |       |       |       |       |
// +-------+-------+-------+-------+-------+-------+       +-------+-------+-------+-------+-------+-------+
// |       |       |       |       |       |       |       |       |       |       |       |       |       |
// +-------+-------+-------+-------+-------+-------+       +-------+-------+-------+-------+-------+-------+
//         |       |       |       |       |       |       |       |       |       |       |       |
//         +-------+-------+-------+-------+-------+       +-------+-------+-------+-------+-------+

    default_layer { // #define L_DEF 0
      bindings = <
    &none             &none            &ad_z        &kp   O             &kp P           &kp Y          &kp W            &kp C          &kp M         &kp V        &none          &none
    &lyht L_FUN Q     &lyht L_NAV H    &moht LALT A &moht LCTRL E       &lyht L_NUM I   &moht LWIN U   &moht LWIN D     &lyht L_NUM T  &moht LCTRL N &moht LALT S &lyht L_NAV R  &lyht L_FUN X
    &ltt L_DEF L_NUM  &ad_j            &ad_oe       &ad_ae              &lyht L_DEAD K  &kp RA(Y)      &kp B            &lyht L_DEAD G &kp L         &kp F        &shsz          &ltt L_DEF L_NUM
                      &none            &kp ESC      &hold_shift LSHFT A &ht LS(TAB) TAB &none          &none            &kp RET        &kp SPACE     &shbs        &none
        >;
    };

    navigation_layer { // #define L_NAV 1
      bindings = <
    &none             &none            &nd_grave    &kp LS(COMMA)       &kp LS(DOT)     &kp EXCL       &mkp LCLK        &kp HOME       &kp UP        &kp PG_UP    &none          &none
    &nd_caret         &nd_dqt          &nd_apos     &kp COMMA           &kp DOT         &kp QMARK      &mkp MCLK        &kp LEFT       &kp SLCK      &kp RIGHT    &move_beg      &kp INS
    &ltt L_DEF L_FUN  &kp RA(LS(SEMI)) &kp RA(N9)   &kp SEMI            &kp COLON       &kp UNDER      &mkp RCLK        &kp END        &kp DOWN      &kp PG_DN    &move_end      &ltt L_DEF L_FUN
                      &trans           &trans       &trans              &trans          &trans         &trans           &trans         &trans        &trans       &none
      >;
    };

    numbers_layer { // #define L_NUM 2
      bindings = <
    &none             &none            &kp RA(N5)   &kp LBRC            &kp RBRC        &kp PIPE       &ht_apos A MINUS &kp N7         &kp N8        &kp N9       &none         &none
    &nd_tilde         &kp LBKT         &kp RBKT     &kp LPAR            &kp RPAR        &kp BSLH       &kp PLUS         &kp N4         &kp N5        &kp N6       &ht COMMA DOT &kp EQUAL
    &ltt L_DEF L_NAV  &kp AT           &kp HASH     &kp DLLR            &kp PRCNT       &kp AMPS       &ht_caret A STAR &kp N1         &kp N2        &kp N3       &kp SLASH     &ltt L_DEF L_NAV
                      &trans           &trans       &trans              &trans          &trans         &trans           &trans         &kp N0        &trans       &none
      >;
    };

    functions_layer { // #define L_FUN 3
      bindings = <
    &none             &none            &none        &none               &none           &kp C_BRI_UP   &kp K_VOL_UP     &kp F7         &kp F8        &kp F9       &none         &none
    &none             &none            &none        &none               &none           &kp C_BRI_AUTO &kp K_MUTE       &kp F4         &kp F5        &kp F6       &kp F11       &kp F10
    &ltt L_DEF L_BLE  &none            &none        &none               &none           &kp C_BRI_DN   &kp K_VOL_DN     &kp F1         &kp F2        &kp F3       &kp F12       &ltt L_DEF L_BLE
                      &trans           &trans       &trans              &trans          &trans         &trans           &trans         &kp SPACE     &trans       &trans
      >;
    };

    secret_layer { // #define L_BLE 4
      bindings = <
    &none             &none            &none        &none               &none           &none          &none            &none          &none         &none        &none         &none
    &none             &none            &none        &none               &none           &none          &bt BT_SEL 1     &bt BT_SEL 2   &bt BT_SEL 3  &bt BT_SEL 4 &bt BT_SEL 5  &none
    &ltt L_DEF L_DEF  &none            &none        &none               &none           &none          &none            &out OUT_USB   &bt BT_CLR    &out OUT_BLE &none         &ltt L_DEF L_DEF
                      &trans           &kp ESC      &trans              &trans          &trans         &trans           &trans         &trans        &trans       &trans
      >;
    };

    one_shift_layer { // #define L_SHF 5
      bindings = <
    &trans            &trans           &trans       &trans              &trans          &trans         &trans           &trans         &trans        &trans       &trans        &trans
    &trans            &trans           &trans       &trans              &trans          &trans         &trans           &trans         &trans        &trans       &trans        &trans
    &trans            &trans           &trans       &trans              &trans          &trans         &trans           &trans         &trans        &trans       &trans        &trans
                      &trans           &trans       &mycaps             &trans          &trans         &trans           &trans         &trans        &trans       &trans
      >;
    };

    dead_key_layer { // #define L_DEAD 6
      bindings = <
    &trans            &trans           &kp GRAVE    &trans              &trans          &trans         &trans           &trans         &trans        &trans       &trans        &trans
    &kp CARET         &kp DQT          &kp APOS     &kp TILDE           &trans          &trans         &trans           &trans         &trans        &trans       &trans        &trans
    &trans            &trans           &trans       &trans              &trans          &trans         &trans           &trans         &trans        &trans       &trans        &trans
                      &trans           &trans       &trans              &trans          &trans         &trans           &trans         &trans        &trans       &trans
      >;
    };
  };
};
